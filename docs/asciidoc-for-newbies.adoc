= AsciiDoc for Newbies
Dan Allen
:max-width: 650px
ifdef::asciidoctor[]
:stylesheet: asciidoctor.css
endif::asciidoctor[]
:toc:

////
TODO:

- attributes (cover in header section)
- links and images
- tables
- $$ and +++ (perhaps in quoted text section)
- block titles section empty

- brief bit comparing AsciiDoc to Markdown
- mention a few places AsciiDoc is being used
- where does Asciidoctor fit in? Perhaps mention it's a drop-in replacement for the asciidoc command?
////

++++
<style>
.prewrap pre {
  white-space: pre-wrap;
}
.wrap pre {
  white-space: normal;
}
.mono {
  font-family: monospace;
}
.red {
  color: red;
}
.green {
  color: green;
}
.blue {
  color: blue;
}
.orange {
  color: orange;
}
.purple {
  color: purple;
}
</style>
++++

This guide provides a gentle introduction to http://asciidoc.org[AsciiDoc], a [mono]#plain# [mono]#text# documentation *syntax* and *processor*.
This introduction is intended for anyone who wants to reduce the work required to write and publish content, whether it be for technical documentation, articles, websites or good ol'-fashioned prose.

In this guide, you'll learn:

- What AsciiDoc is and how it simplifies writing
- The difference between the AsciiDoc syntax and AsciiDoc processors
- The basic structure of an AsciiDoc document
- How to create your first AsciiDoc document
- How to add other structural elements such as lists, quotes and source code

_In addition to covering the AsciiDoc basics, this guide also recommends a set of conventions to help you create more consistent documents and maximize your writing productivity._

Before we get into how you compose a document in AsciiDoc, we'll briefly explore what it is, what need it fills and why you should consider using it as the foundation for your next writing project.

== What is AsciiDoc?

AsciiDoc is a plain text document format for writing notes, documentation, articles, books, ebooks, web pages, slide decks, blog posts, man pages and more.
An AsciiDoc processor can translate documents written using the AsciiDoc syntax into various formats (called _backends_), including HTML 5, DocBook 4.5 and PDF.

Thus, AsciiDoc is two things:

. A mature, http://en.wikipedia.org/wiki/Lightweight_markup_language[lightweight markup language] (i.e., syntax) for authoring documents in plain text{empty}footnote:[AsciiDoc is over 10 years old. It was first introduced in 2002.]
. A software tool, written in Python, that converts the text to a fully-formatted document for presentation like HTML or PDF{empty}footnote:[There's a modern implementation of AsciiDoc, written in Ruby, named http://asciidoctor.org[Asciidoctor].]

Now that we've established what AsciiDoc is, let's consider why we need it.

== Why AsciiDoc?

As humans, we seem to have no trouble talking or thinking.
In fact, we're fluent in it.
It's an activity that just happens whenever a thought ``hits'' us.

_Writing, on the other hand, rarely comes so easy._

When it's time to write our thoughts down, we _struggle_ to find the words--or, at least, how to arrange and organize them.
That _damn_ inner critic disrupts the stream of conciousness we coast on while talking or thinking.

_Or does it?_

=== Writing e-mail vs writing documents

Let's ponder our daily lives.
We respond to dozens of e-mail and social media messages every day.
That involves communication through writing.
That's right, _writing!_

Yet, admist the flurry of typing that occurs when we respond to an e-mail, we hardly even realize we're doing it...and _fluently!_

As it turns out...

[quote, 'http://blog.stoyanstefanov.com/asciidoc[Stoyan Stefanov]']
Most people are OK with writing e-mails.
They don't consider this writing.
There's no writer's block.
Someone asks you a question, you [press] reply and type away.

_So why do we struggle to write ``documents''? You know, articles, wiki pages, documentation, books and such._

One of the main reasons we struggle to write documents is because we don't write them the same way we write e-mail.
Instead, we get tied up with complex word processing tools, bury the content in XML schemas (e.g., HTML and DocBook) or wrestle with finicky WSYWIG editors.

.Word processors, the real writer's block
****
When you're in the writing (i.e., http://blog.stoyanstefanov.com/writing-vs-typing/[typing]) phase, you want the words to flow onto the screen with minimal distractions and interruptions.
Flow, not just time, is essential.

Most word processors excel at distracting you from writing.
The result: you write less (ironic, huh?).

With a word processor, before you type the first word on a blank white screen, you're forced to think about what font family you want, what font size you want, what lines spacing you want and so on.
Once you do get going, auto-correct, spelling and grammar suggestions entice you to backtrack and lose your next thought.
``Smart'' quotes and auto-linking messes up the text as fast as you can enter it.
If you paste text, it likely gets added to the document with a different font family, size and even color.

*Undo. Undo. Undo!*

Let's not even talk about inserting source code.
The designers of the program clearly did not.

*Format. Format. Format!*

After using a word processor, you rightfully conclude it's trying to _sabotage_ your writing process.
****

We struggle to write documents because *we get distracted by stuff that isn't writing*.

Writing documents, especially technical documentation, is hard enough.
Why do we make it harder?
//We don't want to use tools that make it even harder.
//or? more difficult.

*We _need_ to find an easier way to write!*

=== Using what you know

'What if you could write docs like you write e-mail?'

Imagine being able to forget about layout, typesetting and styling (and even some of the semantics) and just _write_.
Let your thoughts flow.
That's the idea behind *lightweight markup languages* such as Markdown and AsciiDoc.

Here's how MarkDown was first introduced:

[quote, John Gruber, Creator of Markdown]
____
The overriding design goal for Markdown's formatting syntax is to make it as readable as possible.

A Markdown-formatted document should be publishable as-is, as plain text, without looking like it's been marked up with tags or formatting instructions.

The single biggest source of inspiration for Markdown's syntax is the format of plain text e-mail.
____

Similarly, here's how AsciiDoc was introduced:

[quote, Stuart Rackham, Creator of AsciiDoc]
____
You write an AsciiDoc document the same way you would write a normal text document.
There are no markup tags or weird format notations.
AsciiDoc files are designed to be viewed, edited and printed directly or translated to other presentation formats.
____

These languages are designed to enable humans to write documents, and for other humans to be able to read them, *_as is_*, in _raw_ form.

=== Why AsciiDoc works

////
- It's readable
- It's comprehensive
- It's extensible
- It produces beautiful output (in HTML, DocBook, PDF, ePub and more)
easy-to-read, easy-to-write
let you focus on expressing your ideas
very close to the simplest thing that could possibly work
A user unfamiliar with AsciiDoc can figure out the semantics by looking
"based on time-tested plain text conventions from the last 40 years of computing."
"simple, intuitive and as such is easily proofed and edited."
designed for people, not computers
"Writing with MultiMarkdown allows you to separate the content and structure of your document from the formatting.
You focus on the actual writing, without having to worry about making the styles of your chapter headers match, or ensuring the proper spacing between paragraphs.
And with a little forethought, a single plain text document can easily be converted into multiple output formats without having to rewrite the entire thing or format it by hand."
////

AsciiDoc, in particular, is about writing with ease.
AsciiDoc is easy to write and its easy to read (in raw form).
After all, it's plain text, just like that familiar e-mail.

It also happens to recognize time-tested, plain text conventions for marking up or structuring the text when you sense it's needed.
In other words, the syntax is probably close to what you've been using in your e-mails.
A user unfamiliar with AsciiDoc can figure out the structure and semantics (i.e., what you meant) just by looking.
Best of all, it only requires a text editor to read or write it.

...

=== Backends for every occasion

...

We'll now delve into the AsciiDoc syntax.
Hopefully you'll agree that it just makes sense.

== Writing in AsciiDoc: First steps

By the end of this section, you'll have composed your AsciiDoc document--hopefully looking back in amazement about how natural it felt.

Your story begins in your favorite text editor...

=== ``It's just text, mate.''

Since AsciiDoc syntax is just [mono]#plain# [mono]#text#, you can write an AsciiDoc document using _any_ text editor.
You don't need complex word processing programs like Microsoft Word, OpenOffice Writer or Google Docs.
In fact, you _shouldn't_ use these programs because they add cruft to the document that you can't see and wreaks havoc on your document.

TIP: While it's true any text editor will do, I recommend selecting an editor that supports syntax highlighting for AsciiDoc.
The *[red]##c##[green]##o##[purple]##l##[orange]##o##[blue]##r##* added by syntax highlighting adds contrast to the text, which makes it easier to read.
The highlighting also gives you hints when you've entered proper syntax for an inline or block element.

The most popular application for editing plain text on MacOSX is *TextMate*.
A similar choice on Linux is *GEdit*.
On Windows, you should stay away from Notepad and Wordpad because the plain text they produce is not cross-platform friendly.
Opt instead for a competent text editor like *Notepad+*.
If you're a programmer (or a writer with an inner geek), you'll likely prefer *VIM*, *Emacs* or *Sublime Text*, all available across platforms.
All of these editors provide http://asciidoc.org/#_editor_support[syntax highlighting for AsciiDoc].

TIP: You don't need any special tooling to write in AsciiDoc.
However, if you want to see the final HTML output while you are writing, refer to the link:editing-with-live-preview.html[Editing with Live Preview] tutorial to learn how to set up instant preview.

Open your favorite text editor and let's start writing in AsciiDoc!

=== Content is king!

All that's required to create a valid AsciiDoc document is one or more paragraphs:

[role="prewrap"]
....
In AsciiDoc, the main structural element is the paragraph.
A paragraph consists of adjacent lines of text.

When you want to start a new paragraph, just hit the Enter key twice and continue typing.
....

*In other words, you write AsciiDoc like you're writing an e-mail.*

.Wrapping lines of text
****
[role="prewrap"]
....
Adjacent lines like these are combined to form a single paragraph.
That means you can wrap paragraph text
or put each sentence on a separate line
and the line breaks won't appear in the output.
....

Here's how the previous lines look when rendered:


[role="wrap"]
....
Adjacent lines like these are combined to form a single paragraph.
That means you can wrap paragraph text
or put each sentence on a separate line
and the line breaks won't appear in the output.
....

If you want line breaks in a paragraph to be preserved, add the following attribute entry to the header of your document (below the title, author and revision lines):

 :hardbreaks:

The hard line breaks setting applies to the whole document.
****

There are certain statements that you want to place more emphasis by taking them out of the flow and labeling them with a priority.
These are called _admonition_ paragraphs.
You make an admonition paragraph by prefixing it with a uppercase label, such as in this note:

----
NOTE: Admonition paragraphs call attention to special words of advice.
----

The following labels are recognized:

* NOTE
* TIP
* WARNING
* CAUTION
* IMPORTANT

The label is displayed in the gutter of the paragraph.
By default, the text of the label is used.
If the +icons+ attribute is set on the document, an icon will be used instead.

NOTE: Admonitions can also encapsulate any block content, which we'll cover later.

If paragraphs are the meat of the content, then titles and sections are the bones.
Let's explore how to give structure to our document.

=== Titles, titles, titles

AsciiDoc supports three types of titles:

. Document title
. Section title
. Block title

This section will define each title type and explain how and when to use them.

==== Document title

Just as every e-mail has a subject, every document (typically) has a title.
The title goes at the top of the document.

TIP: A document title is an _optional_ feature of an AsciiDoc document.

To create a document title, begin the first line of the document with one equal sign followed by at least one space (++= ++) and then the title text.
This syntax is the simplest (and thus recommended) way to declare a document title.

Here's an example of the document title syntax and an abbreviated paragraph:

----
= Lightweight Markup Languages

According to Wikipedia...
----

Notice the blank line between the title line and the first line of content.
This blank line separates the document header from the document body (in this case a paragraph).
The document title is stored in the document's header along with any metadata and document-wide settings.
(If the title line is not offset by a blank line, it gets interpreted as a section title, which we'll discuss later).

The document now has a title, but who's the author?
Good question.
Just as every e-mail has a sender, every document must have an author.
Let's see how to add that information to the header.

There are two optional lines of text you can add immediately below the document title for defining common document attributes:

Line 1:: Author name and (optional) e-mail address
Line 2:: Date and revision

Let's add those lines to our document:

----
= Lightweight Markup Languages
Doc Writer <doc.writer@asciidoc.org>
2012-01-01

According to Wikipedia...
----

The header now containes a document title, an author and a date.
This information will be formatted when the document is rendered.

*That's all there is to it.
You're now writing in AsciiDoc!*

NOTE: The header, including the document title, is _not required_.
If absent, the AsciiDoc processor will happily render whatever content is present.
The header is only used when rendering a full document.
It's excluded from the output of an embedded document.

For short documents, a document title may be sufficient.
As your document gets longer, you'll want to organize the content into sections.
That's accomplished using section titles.

==== Section titles

In AsciiDoc, sections are created using section titles.
Sections are used to partition the document into a content hierarchy.

A section title uses the same syntax as a document title, except the line may begin with two to five equal signs instead of just a single equal sign.
The number of equal signs represents the nesting level (using a 0-based index).

Here are all the section levels permitted in an AsciiDoc document, shown below the document title:

----
= Document Title (Level 0)

== Level 1 Section

=== Level 2 Section

==== Level 3 Section

===== Level 4 Section

== Another Level 1 Section
----

NOTE: When the document is rendered as HTML 5 (using the built-in html5 backend), each section title becomes a heading element where the heading level matches the number of equal signs.
For example, a level 1 section maps to an +<h2>+ element.

Section levels cannot be choosen arbitrarily.
There are two rules you must follow:

. A document can only have a single level 0 section (in addition to the document title) if the +doctype+ is set to +book+ (the default is article)
. Section levels cannot be skipped when nesting sections

For example, the following syntax is illegal:

----
= Document Title

== First Section

==== Illegal Nested Section

= Illegal Level 0 Section
----

Once the first section is reached, content gets associated with the section that proceeds it:

----
== First Section

Content of first section

=== Nested Section

Content of nested section

== Second Section

Content of second section
----

===== Preamble

Text can proceed the first section.
It is called the preamble, though you don't need to use any syntax to designate this text.

----
= Document Title

preamble

another preamble paragraph

== First Section
----

==== Block titles

...

=== Some mild punctuation

When you write, there are certain words and phrases you'll want to emphasis.
You may do so to communicate intonation you'd use when speaking the word.
In other cases, you want to give a word or phrase special meaning, such as a reference to a file path or source code construct.

In an e-mail, you might "speak" a word louder by surrounding the word with asterisks.

----
I can't believe it, he *won*!
----

In AsciiDoc, that punctuation makes the text bold.
AsciiDoc refers to this markup as _quoted text_.
The term quote is used liberally here to apply to any symbols that surround text in order to apply emphasis or special meaning.

Here are all the forms of quoted text that AsciiDoc recognizes.

* \*Asterisks* around text make it *bold*
* \'Single quotes' around text make it 'italic'
* \_Underscores_ around text also make it _italic_
* \+Pluses+ around text make it _monospaced_
* \#Hashes# around text allows it to be assigned a [kbd]#role#
* \^Carrots^ around text make it ^superscript^
* \~Tildes~ around text make it ~subscript~
* `Smart' single quotes consist of a \`leading backtick and trailing single quote'.
* ``Smart'' double quotes consist of \\``two leading backticks and two trailing single quotes''.

When you want to place emphasis somewhere other than at the boundaries of a word, then you need to double up the punctuation.
For instance, to emphasis the first letter of a word, you would surround it in double asterisks:

----
**F**our score and seven years ago...
----

Any quoted text can be prefixed with an attribute list.
The first positional attribute is treated as a role.
The role can be used to apply custom styling to the text.
For instance:

----
Type the word [kbd]#asciidoc# into the search bar.
----

If you are getting quoted text behavior where you don't want it, simply prefix the punctuation with a backslash:

----
\*Stars* will not become bold, but rather surrounded by asterisks.
----

You can also enclose text in backticks to make it monospaced.
The backticks also prevent any further processing of the text, so it gets rendered exactly as it's written.

----
The asterisks in this `*monospaced phrase*` will appear in the output.
----

AsciiDoc also recognizes well-known textual representation of symbols, arrows and dashes:

[options="header"]
|===
|Name |AsciiDoc Source |As Rendered

|copyright
|$$(C)$$
|(C)

|registered trademark
|$$(R)$$
|(R)

|trademark
|$$(TM)$$
|(TM)

|em dash (between words)
|$$--$$
|{empty}--{empty}

|ellipses
|$$...$$
|...

|arrows
|$$-> => <- <=$$
|-> => <- <=

|apostrophe
|$$Sam's$$
|Sam's

|XML entity (e.g., dagger)
|$$&#8224;$$
|&#8224;

|===

This mild punctuation does not take away from the readability of the text.
In fact, you could argue that it makes the text easier to read.
What's important is that these are conventions with which you are likely already familiar.

Punctuation is used in AsciiDoc to create another very common type of element in documents, _lists!_

=== Lists, lists, lists

There are three types of lists supported in AsciiDoc:

. _Unordered_
. [mono]#Ordered#
. *Labeled*

_Unordered_ and [mono]#ordered# lists are structurally very similar.
You can think of them as outline lists that use different types of markers (i.e., bullets).
In contrast, *labeled* lists are a collection of labels that each have supporting content and they are rarely nested.

Let's explore how to define each type of list, then play around with mixing and matching them.
We'll also cover how you include complex content inside a list item.

==== Lists of things

If you had to create a list of items in an e-mail, how would you do it? Chances are, what you'd type is exactly how you define an outline list in AsciiDoc.

Here's an example of a grocery list written as an unordered list in AsciiDoc:

----
* Milk
* Eggs
* Bread
* Lettuce
* Tomatoes
----

Was your instinct to use a hypen instead of an asterisk? Guess what? That works too:

----
- Milk
- Eggs
- Bread
- Lettuce
- Tomatoes
----

In either case, you don't need to see the output.
You already know how it will look ;)

NOTE: The marker must be aligned with the left margin and the item text must be offset from the marker by at least one space.

What if you wanted to group the grocery list by aisle? Then you might organize it as a nested list.

To get a nested item, just add another asterisk in front of the item:

----
* Produce
** Lettuce
** Tomatoes
* Bakery
** Bread
* Diary
** Milk
** Eggs
----

You can have up to five levels of nesting:

----
* Kingdom
** Phylum
*** Class
**** Order
***** Family
----

The hyphen doesn't work for nested lists since repeating hypens are used for other purposes in AsciiDoc.

[TIP]
====
Since a hyphen only works for a single level nesting in an AsciiDoc list, I recommend reserving the hyphen for lists that only have a single level:

.List without nested items
----
- Ubuntu
- Fedora
- Slackware
----

For lists that have more than one level, use asterisks:

.List with nested items
----
* Linux
** Ubuntu
** Fedora
** Slackware
* BSD
** FreeBSD
** NetBSD
* MacOSX
----

Technically, the number of asterisks doesn't represent the nesting level.
Rather, a new level is created for each unique marker.
However, it's much more intuitive to follow the convention:

 # of asterisks = level of nesting

After all, we are shooting for plain text markup that is readable _as is_.
====

==== Ordering the things

Sometimes, we need to number the items in a list.
Instinctually, you might prefix each item with a number, like in this next list:

----
1. Protons
2. Electrons
3. Neutrons
----

Since numbers in an ordered list are sequential, you can leave them off an AsciiDoc will calculate them automatically:

----
. Protons
. Electrons
. Neutrons
----

Like with unordered lists, you create a nested item by using multiple dots in front of the item:

----
. Introduction
. Getting Started
.. Installing the program
.. Launching the program
. Titles
.. Document
.. Section
.. Block
. Lists
.. Outline
... Unordered
... Ordered
.. Labeled
----

[TIP]
====
Similar to asterisks in unordered lists, the number of dots doesn't represent the nesting level.
Rather, a new level is created for each unique marker.
However, it's much more intuitive to follow the convention:

 # of dots = level of nesting

After all, we are shooting for plain text markup that is readable _as is_.
====

AsciiDoc selects a different number scheme for each level of nesting.
Here's how the previous list renders:

. Introduction
. Getting Started
.. Installing the program
.. Launching the program
. Titles
.. Document
.. Section
.. Block
. Lists
.. Outline
... Unordered
... Ordered
.. Labeled

The following table shows the number scheme used by default for each nesting level:

.Order list numbering schemes by level
[cols="2,3,3" options="header"]
|===
|List Level |Numbering Scheme      |CSS class (HTML backend)
|1
|Arabic
|arabic

|2
|Lower Alpha
|loweralpha

|3
|Lower Roman
|lowerroman

|4
|Upper Alpha
|upperalpha

|5
|Upper Roman
|upperroman
|===

You can override the number scheme for any level by setting its style (first position in a block attribute list).
You can also set the starting number using the +start+ attribute:

----
[lowerroman, start="5"]
. Five
. Six
[loweralpha]
.. a
.. b
.. c
. Seven
----

==== Titling a list

You can give any block element, such as a list, a title by prefixing the line with a dot immediately followed by the text (without leaving any space after the dot).

Here are examples of two lists with titles:

----
.Shopping list
* Milk
* Eggs
* Bread

.Parts of an atom
. Protons
. Electrons
. Neutrons
----

==== Labeled lists

Labeled lists are useful when you need to include commentary about each item in a list.
Each item consists of a label followed by:

* a separator (typically a double colon, +::+)
* at least one space or endline
* the item's content

Here's a labeled list that identifies various parts of a computer:

----
CPU:: The brain of the computer.
Hard drive:: Permanent storage for operating system and/or user files.
RAM:: Temporarily stores information the CPU uses during operation.
Keyboard:: Used to enter text or control items on the screen.
Mouse:: Used to point to and select items on your computer screen.
Monitor:: Displays information in visual form using text and graphics.
----

By default, the content of each item is displayed below the label when rendered.
If you want the label and content to appear on the same line, add the horizontal style to the list.

----
[horizontal]
CPU:: The brain of the computer.
Hard drive:: Permanent storage for operating system and/or user files.
RAM:: Temporarily stores information the CPU uses during operation.
----

The content of a labeled list can be any AsciiDoc element.
For instance, we could rewrite the grocery list from above so that each aisle is a label rather than a parent outline list item.

----
.Grocery list, organized by aisle
Produce::
* Lettuce
* Tomatoes
Bakery::
* Bread
Diary::
* Milk
* Eggs
----

Labeled lists are _very_ lenient about whitespace, so you can spread the items out and even indent the content if that makes it more readable for you:

----
.Grocery list, organized by aisle

Produce::

  * Lettuce
  * Tomatoes

Bakery::

  * Bread

Diary::

  * Milk
  * Eggs
----

==== Hybrid lists

You can mix the three list types in a single list.
AsciiDoc works hard to infer the relationships between the items that are most intuitive to us humans.

Here's a simple example of nesting an unordered list inside of an ordered list:

----
. Linux
* Ubuntu
* Fedora
* Slackware
. BSD
* FreeBSD
* NetBSD
. MacOSX
----

Again, you can spread the items out and indent the nested lists if that makes it more readable for you:

----
. Linux
  * Ubuntu
  * Fedora
  * Slackware

. BSD
  * FreeBSD
  * NetBSD

. MacOSX
----

Here's a list that mixes all three types of lists:

----
Operating Systems::

  . Linux
    * Ubuntu
    * Fedora
    * Slackware
  
  . BSD
    * FreeBSD
    * NetBSD
  
  . MacOSX

Cloud Providers::

  . PaaS
    * OpenShift
    * CloudBees

  . IaaS
    * Amazon EC2
    * Rackspace
----

==== Complex list content

So far, all of the list items have only had one line of text (aside from nested lists).
However, a list item can hold any type of AsciiDoc content, including paragraphs, listing blocks and even tables.
We'll start with the simplest case and continue adding on.

Like with regular paragraph text, the text of a list item can wrap across any number of lines, as long as all the lines are adjacent.
For example:

----
* The header in AsciiDoc is optional, but if
  it is used it must start with a document title.

* Optional Author and Revision information
  immediately follows the header title.

* The document header must be separated from
  the remainder of the document by one or more
  blank lines and cannot contain blank lines.
----

TIP: When items contain more than one line of text, leave a blank line before the next item to make the list easier to read.

If you want to attach additional paragraphs to a list item, you "add" them together using a _list continuation_.
A list continuation is a +{plus}+ symbol on a line by itself, immediately adjacent to the two elements it's connecting.
Here's an example:

----
* The header in AsciiDoc must start with a
  document title.
+
The header is optional.

* Optional Author and Revision information
  immediately follows the header title.
----

You can use the list continuation any number of times in a single list item.
Using that list continuation, you can attach any type of block element.

Here's an example that attaches both a listing block and an admonition paragraph to the first item:

[listing]
....
* The header in AsciiDoc must start with a
  document title.
+
----
= Document Title
----
+
NOTE: The header is optional.

* Optional Author and Revision information
  immediately follows the header title.
+
----
= Document Title
Doc Writer <doc.writer@asciidoc.org>
v1.0, 2013-01-01
----
....

// (more?)

==== Dividing lists

If you have adjacent lists, they have the tendency to want to fuse together.
To force the lists apart, place a line comment between them, offset on either side by a blank line.
Here's an example:

----
* Apples
* Oranges
* Bananas

// list divider

* Walnuts
* Almonds
* Cashews
----

=== Links and images

...

== More building blocks

AsciiDoc provides a nice set of components for including non-paragraph text--such as quotes, source code listings, sidebars and tables--in your document.
These components are referred to as _delimited blocks_ because they are surrounded by delimiter lines.

You've already seen many examples of the listing block, which is surrounded by lines with four or more hypens.

[listing]
....
----
This is an example of a _listing block_.
The content inside is rendered as <pre> text.
----
....

Within the boundaries of a delimited block, you can enter any AsciiDoc content and blank lines.
The block doesn't end until the ending delimiter is found.
The delimiters around the block determine the type of block, how the content is processed and rendered and what elements are used to wrap the content in the ouput.

Here's how the block above appears when rendered as HTML:

----
This is an example of a _listing block_.
The content inside is rendered as <pre> text.
----

Here's the HTML that gets generated:

----
<div class="listingblock">
  <div class="content monospaced">
    <pre>This is an example of a _listing block_.
The content inside is rendered as &lt;pre&gt; text.</pre>
  </div>
</div>
----

You should notice a few things about how the content is processed:

* the HTML tag +<pre>+ is escaped
* then endlines are preserved
* the phrase "listing block" is not italicized, despite having underscores around it.

Literal blocks don't receive the full set of substitutions normally applied to a paragraph.
Each block is processed according to it's purpose.
Since a listing block is typically used for source code, substitutions are not desirable.

The following table identifies the delimited blocks that AsciiDoc provides by default, their purpose and what substitutions are performed on its content.

[cols="1,1m,1,1" options="header"]
|===
|Name (Style) |Delimiter |Purpose |Subsitutions

|comment
|$$////$$
|Private notes that are not displayed in the output
|None

|example
|$$====$$
|Designates example content or defines an admonition block
|Normal

|literal
|$$....$$
|Output text to be displayed exactly as entered
|Verbatim

|listing, source
|$$----$$
|Source code or keyboard input to be displayed as entered
|Verbatim

|open
|$$--$$
|Anonymous block that can act as any other block (except _pass_ or _table_)
|Varies

|pass
|$$++++$$
|Raw text that should be passed through unprocessed
|None

|quote, verse
|$$___$$
|A quotation or verse with optional attribution
|Normal

|sidebar
|$$****$$
|Aside text rendered outside the flow of the document
|Normal

|table
|$$\|===$$
|Used to display tabular content or advanced layouts
|Varies

|===

This table shows the subsitutions performed by each substitution group referenced in the previous table.

[options="header"]
|===
|Name     |Special characters |Callouts |Quotes |Attributes |Replacements |Macros |Post replacements
h|Normal   |Yes                |No       |Yes    |Yes        |Yes          |Yes    |Yes
h|Verbatim |Yes                |Yes      |No     |No         |No           |No     |No
h|None     |No                 |No       |No     |No         |No           |No     |No
|===

...

=== Block metadata

Metadata can be assigned to any blocks.
There are several types of metadata:

* Title
* Id (i.e., anchor)
* Style
* Extra attributes

Here's an example of a block that includes all types of metadata:

----
.Gettysburg Address
[[gettysburg]]
[quote, Abraham Lincoln, Soldiers' National Cemetery Dedication]
____
Four score and seven years ago our fathers brought forth
on this continent a new nation...

Now we are engaged in a great civil war, testing whether
that nation, or any nation so conceived and so dedicated,
can long endure. ...
____
----

Here's the metadata extracted from this block:

Title:: Gettysburg Address
Id:: gettysburg
Style:: quote
Extra attributes::
  * attribution="Abraham Lincoln"
  * citetitle="Dedication of the Soldiers' National Cemetery"

Some metadata is used as supplementary content, such as the title, whereas other metadata controls how the block is rendered, such as the style.
Consult the http://asciidoc.org/userguide.html#X104[Delimited Blocks] chapter in the AsciiDoc User Guide for a full list of the metadata that is applicable for each block.

=== Masquarading blocks

Some blocks can masquarade as other blocks, a feature which is controlled by the block style.
The block style is the first positional attribute in the block attribute list.

For instance, an example block can act as an admonition block:

----
[NOTE]
====
This is an example of an admonition block.

Unlike an admonition paragraph, it may contain any AsciiDoc content.
The style can be any one of the admonition labels:

* NOTE
* TIP
* WARNING
* CAUTION
* IMPORTANT
====
----

At the start of this tutorial, remember how painful we said it is to insert source code into a document using a traditional word processor. They just aren't designed for that use case. *AsciiDoc is!*

Inserting source code in an AsciiDoc is incredibly easy. Just shove the raw code into a listing block.

[listing]
....
----
require 'asciidoctor'

puts Asciidoctor.render_file('sample.ad', :header_footer => true)
----
....

To enable syntax highlighting in the output, set the style on the block to +source+ and specify the source language in the second attribute position.

[listing]
....
[source,ruby]
----
require 'asciidoctor'

puts Asciidoctor.render_file('sample.ad', :header_footer => true)
----
....

You can even use source code that's in a separate file. Just use the AsciiDoc include macro:

[listing]
....
[source,ruby]
----
\include::example.rb[]
----
....


The most versatile of all, an open block can act as any other block, with the exception of _pass_ and _table_.

----
[sidebar]
.Related information
--
This is aside text.

It is used to present information related to the main content.
--
----

The style can also be used in the absense of block delimiters.

=== When delimiters are optional

If the content is contiguous (not interrupted by blank lines), you can forgo the use of the block delimiters and instead use the block style above a paragraph to repurpose it as one of the delimited block types.

This format is often used for single-line listings:

----
[listing]
sudo yum install asciidoc
----

or single-line quotes:

----
[quote]
Never do today what you can put off til tomorrow.
----

...

=== Tables

...

== Rendering your document

You've created your document.
Now what? Although AsciiDoc is designed to be readable in raw form, you're readers probably aren't going to appreciate getting a plain text file.
Aesthetics matter.
You want to dress up your text in nice typography and colors, adjust the font sizes to adhere to the "golden ratio" and give it the respect it deserves.

That's where the AsciiDoc processor comes in.
The processor parses the document and translates it into a backend format, such as HTML, ePub, DocBook or PDF.
AsciiDoc provides a set of default templates in the tin, but you can customize them to get just about any output you want.
We'll cover the most common usages in this document.

In order to use the AsciiDoc processor, you first have to install it.

=== Installing AsciiDoc

The AsciiDoc processor is a Python script and can be run on any system that has Python installed.footnote:[At the time of writing, the AsciiDoc processor does not work with Python 3.]

==== Installing via a package manager

The quickest way to install AsciiDoc is through the package manager on your system.
Here are the commands for several popular package management systems:

.Ubuntu / Debian
 sudo apt-get install asciidoc

.Fedora
 sudo yum -y install asciidoc

.MacOSX
 brew install asciidoc

NOTE: If Python isn't already installed, it should be installed as a dependency of the package.

If the install was successful, you should be able to execute the +asciidoc+ and +a2x+ commands from a command prompt:

 $> asciidoc --version
 asciidoc 8.6.8
 $> a2x --version
 a2x 8.6.8

==== Installing manually

If you can't get the AsciiDoc processor using a package manager, you can install it manually following these steps:

. Make sure you have Python 2 installed on your system
. http://sourceforge.net/projects/asciidoc/files/latest/download[Download the distribution archive] from the AsciiDoc website.
. Extract the archive into a directory where you keep your programs
. Find the +asciidoc.py+ and +a2x.py+ files in the extracted directory
. Rename these files to +asciidoc+ and +a2x+, respectively
. Add the extracted directory to your PATH environment variable

For more details on the manual install, see the http://asciidoc.org/INSTALL.html[AsciiDoc Installation Guide].

If the install was successful, you should be able to execute the +asciidoc+ and +a2x+ commands from a command prompt:

 $> asciidoc --version
 asciidoc 8.6.8
 $> a2x --version
 a2x 8.6.8

=== Converting a document to HTML 5

There are two HTML backends that come with AsciiDoc:

xhtml11:: Creates an HTML document that adheres to the XHTML 1.1 specification and uses CSS2 for styling
html5:: Create an HTML document that adheres to the HTML 5 specification and uses CSS3 for styling

The default backend in AsciiDoc is *xhtml11*.
If you don't specify a backend, the AsciiDoc processor will assume you want to use *xhtml11*.
We want to look forward, so we're going to use the *html5* backend.

Let's convert our document to HTML 5.
In your command prompt, switch to the directory that contains the document and execute the following command:

 $> asciidoc -b html5 sample.ad

You won't see any messages printed to the console.
If you type +ls+ (or view the directory in a file manager), there is a new file named +sample.html+.

 $> ls
 sample.ad  sample.html

AsciiDoc derives the name of the output document from the name of the input document by simply changing the file extension.

The document uses CSS for styling and JavaScript for generating parts of the document such as the table of contents and footnotes, which it embeds into the document so you don't have to worry about managing extra resources.

However, if you have image references in your document, you still have to move those with the output document.
To have the images embedded into the document as well, pass the +data-uri+ attribute to the processor:

 $> asciidoc -b html5 -a data-uri sample.ad

If you want the document to include a table of contents, pass the +toc+ attribute to the processor:

 $> asciidoc -b html5 -a data-uri -a toc sample.ad

If you want to use +data-uri+ and +toc+ by default, you can add them to the header of the document:

----
= Document Title
Doc Writer <doc.writer@asciidoc.org>
2012-01-01
:data-uri:
:toc:

Content...
----

Admittedly, the default stylesheet that comes with AsciiDoc is quite...blue.
AsciiDoc ships with two additional themes, flask and volnitsky.
People tend to prefer the flask theme, which you can enable using the +theme+ attribute:

 $> asciidoc -b html5 -a theme=flask sample.ad

You can create your own theme.
See the http://asciidoc.org/userguide.html#X99[Themes] chapter in the AsciiDoc User Guide for details.

If you'd rather supply your own stylesheet, you can specify the relative path to it using the +stylesheet+ attribute:

 $> asciidoc -b html5 -a stylesheet=mystyles.css sample.ad

The custom styles will be embedded into the document, as with the default stylesheet.

// TODO -a icons and -a iconsdir

One of the strengths of AsciiDoc is that it can output to a variety of formats, not just HTML.

=== Converting a document to DocBook

Writing in DocBook is inhumane.
The utility of DocBook is providing a portable document format.
Since AsciiDoc was designed with DocBook output in mind, the conversion is very good.

AsciiDoc provides a DocBook 4.5 backend out of the box.
To convert the document to this format, call the processor with the backend flag set to *docbook*:

 $> asciidoc -b docbook sample.ad

A new XML document, named +sample.xml+, will now be present in the current directory:

 $> ls
 sample.ad  sample.html  sample.xml

If you're on Linux, you can view the DocBook file using Yelp:

 $> yelp sample.xml

DocBook is only an intermediary format in the AsciiDoc toolchain.
You'll either feed it into a system that processes DocBook (like https://fedorahosted.org/publican[publican]), or you can convert it to PDF using the AsciiDoc processor.

=== Converting the document to PDF

PDF is a nice format for presenting a final version of a document.
For legacy reasons, the convertion to PDF is handled by a separate program in the AsciiDoc distribution, +a2x+.

+a2x+ can accept a DocBook file as input and produce a PDF:

 $> a2x -f pdf sample.xml

A new PDF document, named +sample.pdf+, will now be present in the current directory:

 $> ls
 sample.ad  sample.html  sample.pdf  sample.xml

You can view the PDF using any PDF viewer.
Go ahead, take a look!

Yes, you just created that PDF.
Yes, it was that easy.

Rather than converting from AsciiDoc to DocBook and then from DocBook to PDF in two steps, +a2x+ can go directly from AsciiDoc to PDF in a single call:

 $> a2x -f pdf sample.ad

// TODO creating slides

==== Output galore

There's really no end to the customization you can do to the output that the AsciiDoc processor(s) generate.
We've just scratched the surface here.
Keep in mind that this magazine was produced from AsciiDoc, so never underestimate how far you can make the output stretch.

If you want to start tweaking the output that is generated, refer to instructions in the http://asciidoc.org/userguide.html[AsciiDoc User Guide].

== Where else you can try AsciiDoc

== Who's using AsciiDoc?

== Next steps

...

////
== Writing in AsciiDoc: Tables and layouts

=== Easy tables

// Explain how they are similar to lists

.Software
[options="header"]
|===
|Name |Type

|Firefox
|Web Browser

|Ruby
|Programming Language

|TorqueBox
|Application Server
|===
////

////
=== Staying close to the code

[quote, 'http://blog.stoyanstefanov.com/asciidoc[Stoyan Stefanov]']
____
The best software for writing a computer book is simply your favorite code editor...as close to [the] source code as possible.

Removing friction out of typing is an enormous help.
[S]omething like AsciiDoc or Markdown makes the process so much easier.
____
////
